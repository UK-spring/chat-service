<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대규모 트래픽 처리를 위한 아키텍처 설계 - 강의 소개</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.7;
            color: #1a1a1a;
            background: #f8f9fa;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }
        
        /* 헤더 */
        .header {
            background: linear-gradient(135deg, #2E5090 0%, #1E3A6D 100%);
            color: white;
            padding: 60px 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 42px;
            font-weight: 700;
            margin-bottom: 20px;
        }
        
        .header .subtitle {
            font-size: 22px;
            opacity: 0.95;
            margin-bottom: 30px;
        }
        
        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 16px;
        }
        
        /* 목차 */
        .toc {
            background: #f4f6f9;
            padding: 40px;
            border-left: 5px solid #2E5090;
        }
        
        .toc h2 {
            color: #2E5090;
            font-size: 28px;
            margin-bottom: 25px;
        }
        
        .toc ul {
            list-style: none;
        }
        
        .toc li {
            padding: 12px 0;
            font-size: 18px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc a {
            color: #2E5090;
            text-decoration: none;
            transition: all 0.3s;
        }
        
        .toc a:hover {
            color: #5B9BD5;
            padding-left: 10px;
        }
        
        /* 섹션 */
        .section {
            padding: 50px 40px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .section h2 {
            color: #2E5090;
            font-size: 36px;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 3px solid #2E5090;
        }
        
        .section h3 {
            color: #4472C4;
            font-size: 26px;
            margin: 35px 0 20px 0;
        }
        
        .section h4 {
            color: #5B9BD5;
            font-size: 20px;
            margin: 25px 0 15px 0;
        }
        
        /* 카드 */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .card {
            background: white;
            border: 2px solid #e0e4e8;
            border-radius: 10px;
            padding: 25px;
            transition: all 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(46,80,144,0.15);
            border-color: #5B9BD5;
        }
        
        .card-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .card h4 {
            color: #2E5090;
            font-size: 20px;
            margin: 0 0 12px 0;
        }
        
        .card p {
            color: #666;
            font-size: 15px;
        }
        
        /* 하이라이트 박스 */
        .highlight-box {
            background: linear-gradient(135deg, #5B9BD5 0%, #2E5090 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin: 30px 0;
        }
        
        .highlight-box h3 {
            color: white;
            margin: 0 0 15px 0;
        }
        
        .info-box {
            background: #f4f6f9;
            border-left: 5px solid #2E5090;
            padding: 25px;
            margin: 25px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff5f0;
            border-left: 5px solid #FF6B35;
            padding: 25px;
            margin: 25px 0;
            border-radius: 5px;
        }
        
        /* 리스트 */
        .section ul {
            margin: 20px 0 20px 25px;
        }
        
        .section li {
            margin: 10px 0;
            padding-left: 10px;
        }
        
        .section ul ul {
            margin: 10px 0 10px 15px;
        }
        
        /* 다이어그램 컨테이너 */
        .diagram-container {
            background: #fafbfc;
            border: 2px solid #e0e4e8;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }
        
        .diagram-title {
            color: #2E5090;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        /* 테이블 */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
        }
        
        .comparison-table th {
            background: #2E5090;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .comparison-table td {
            padding: 15px;
            border: 1px solid #e0e4e8;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f4f6f9;
        }
        
        /* 프로젝트 카드 */
        .project-card {
            background: white;
            border: 3px solid #2E5090;
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
        }
        
        .project-card h4 {
            color: #2E5090;
            font-size: 22px;
            margin-bottom: 15px;
        }
        
        .project-number {
            display: inline-block;
            background: #2E5090;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        /* 스텝 플로우 */
        .flow-step {
            display: flex;
            align-items: center;
            margin: 20px 0;
        }
        
        .flow-number {
            background: #5B9BD5;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .flow-content {
            flex: 1;
        }
        
        /* 푸터 */
        .footer {
            background: #2E5090;
            color: white;
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }
        
        /* 프린트 스타일 */
        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 헤더 -->
        <div class="header">
            <h1>대규모 트래픽 처리를 위한<br>아키텍처 설계</h1>
            <p class="subtitle">Redis, Kafka, Spring Boot 실전 가이드</p>
            <span class="badge">💡 이론 + 실습 + 실전 프로젝트</span>
        </div>
        
        <!-- 목차 -->
        <div class="toc">
            <h2>📑 목차</h2>
            <ul>
                <li><a href="#overview">강의 개요</a></li>
                <li><a href="#chapter1">챕터 1: Redis ZSET</a></li>
                <li><a href="#chapter2">챕터 2: Kafka</a></li>
                <li><a href="#chapter3">챕터 3: Kafka + Spring</a></li>
                <li><a href="#chapter4">챕터 4: 실전 프로젝트</a></li>
                <li><a href="#chapter5">챕터 5: 부하 테스트</a></li>
                <li><a href="#summary">학습 효과 및 요약</a></li>
            </ul>
        </div>
        
        <!-- 강의 개요 -->
        <div id="overview" class="section">
            <h2>📚 강의 개요</h2>
            
            <div class="info-box">
                <h3>🎯 학습 목표</h3>
                <p>본 강의는 실시간 대규모 트래픽을 효율적으로 처리하는 시스템 설계 능력을 습득하고, Redis와 Kafka를 활용한 실전 아키텍처 구현 경험을 쌓는 것을 목표로 합니다.</p>
            </div>
            
            <h3>핵심 기술 스택</h3>
            <div class="card-grid">
                <div class="card">
                    <div class="card-icon">⚡</div>
                    <h4>Redis ZSET</h4>
                    <p>실시간 랭킹 시스템 구현을 위한 정렬된 집합 자료구조</p>
                </div>
                <div class="card">
                    <div class="card-icon">🚀</div>
                    <h4>Kafka</h4>
                    <p>대용량 이벤트 스트리밍 및 시스템 간 비동기 통신</p>
                </div>
                <div class="card">
                    <div class="card-icon">🔧</div>
                    <h4>Spring Boot</h4>
                    <p>Redis와 Kafka를 통합하는 애플리케이션 프레임워크</p>
                </div>
            </div>
            
            <h3>전체 아키텍처 다이어그램</h3>
            <div class="diagram-container">
                <div class="diagram-title">대규모 트래픽 처리 시스템 구조</div>
                <div class="mermaid">
graph LR
    A[사용자 요청] --> B[Spring Boot API]
    B --> C{이벤트 발행}
    C --> D[Kafka Topic]
    D --> E[Consumer Group]
    E --> F[Redis ZSET]
    E --> G[데이터베이스]
    F --> B
    G --> B
    
    style B fill:#2E5090,color:#fff
    style D fill:#FF6B35,color:#fff
    style F fill:#5B9BD5,color:#fff
                </div>
            </div>
        </div>
        
        <!-- 챕터 1: Redis ZSET -->
        <div id="chapter1" class="section">
            <h2>📊 챕터 1: Redis ZSET</h2>
            
            <h3>Redis ZSET이란?</h3>
            <p>Redis의 Sorted Set(ZSET)은 Score 값을 기반으로 자동 정렬되는 집합 자료구조입니다. 각 요소는 고유한 값(member)과 점수(score)를 가지며, score에 따라 자동으로 정렬됩니다.</p>
            
            <div class="highlight-box">
                <h3>⚡ 성능 특징</h3>
                <p><strong>시간 복잡도:</strong> O(log N) - 빠른 조회와 업데이트<br>
                <strong>자동 정렬:</strong> Score 기반 실시간 정렬<br>
                <strong>활용:</strong> 실시간 랭킹, 리더보드, 시계열 데이터</p>
            </div>
            
            <h3>ZSET 동작 원리</h3>
            <div class="diagram-container">
                <div class="diagram-title">ZSET 내부 구조와 조회</div>
                <div class="mermaid">
graph TD
    A[ZSET: 상품 랭킹] --> B[상품A: 1500점]
    A --> C[상품B: 1200점]
    A --> D[상품C: 800점]
    A --> E[상품D: 500점]
    
    F[ZRANGE 0 -1] --> G[전체 조회]
    H[ZREVRANGE 0 2] --> I[TOP 3 조회]
    
    style A fill:#2E5090,color:#fff
    style B fill:#5B9BD5,color:#fff
    style C fill:#5B9BD5,color:#fff
    style D fill:#5B9BD5,color:#fff
    style E fill:#5B9BD5,color:#fff
                </div>
            </div>
            
            <h3>학습 내용</h3>
            
            <h4>1-1. Redis + RedisInsight 환경 설정</h4>
            <div class="flow-step">
                <div class="flow-number">1</div>
                <div class="flow-content">Docker를 이용한 Redis 서버 설치 및 구성</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">2</div>
                <div class="flow-content">RedisInsight GUI 도구 설정 및 활용법</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">3</div>
                <div class="flow-content">Redis 기본 설정 및 보안 구성</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">4</div>
                <div class="flow-content">연결 테스트 및 기본 명령어 실습</div>
            </div>
            
            <h4>1-2. Redis의 ZSET 이해하기</h4>
            <ul>
                <li><strong>ZSET 자료구조의 내부 동작 원리</strong></li>
                <li><strong>주요 명령어:</strong> ZADD, ZRANGE, ZRANK, ZINCRBY, ZREVRANGE 등</li>
                <li><strong>Score 기반 정렬 및 범위 조회</strong></li>
                <li><strong>실시간 랭킹 시스템 구현을 위한 활용 패턴</strong></li>
            </ul>
            
            <h4>1-3. Spring Boot + Redis (ZSET)</h4>
            <ul>
                <li>Spring Data Redis 의존성 추가 및 설정</li>
                <li>RedisTemplate을 이용한 ZSET 연동</li>
                <li>Repository 패턴으로 Redis 접근 추상화</li>
                <li>실시간 인기 상품 TOP 100 API 구현</li>
            </ul>
            
            <h3>실무 활용 사례</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>활용 분야</th>
                        <th>구현 방법</th>
                        <th>비즈니스 효과</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>이커머스 인기 상품 랭킹</strong></td>
                        <td>조회수를 score로 하여 실시간 집계</td>
                        <td>메인 페이지 전환율 향상</td>
                    </tr>
                    <tr>
                        <td><strong>게임 리더보드</strong></td>
                        <td>사용자 점수를 실시간 업데이트</td>
                        <td>유저 참여도 증가</td>
                    </tr>
                    <tr>
                        <td><strong>시계열 데이터 관리</strong></td>
                        <td>타임스탬프를 score로 사용</td>
                        <td>효율적인 데이터 조회</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- 챕터 2: Kafka -->
        <div id="chapter2" class="section">
            <h2>🚀 챕터 2: Kafka</h2>
            
            <h3>Kafka가 필요한 이유</h3>
            <p>현대의 대규모 서비스는 수많은 마이크로서비스로 구성되어 있으며, 이들 간의 통신과 데이터 동기화가 매우 중요합니다. Kafka는 초당 수백만 건의 이벤트를 안정적으로 처리할 수 있는 분산 스트리밍 플랫폼입니다.</p>
            
            <div class="highlight-box">
                <h3>💡 Kafka의 핵심 가치</h3>
                <ul style="color: white; margin: 10px 0 0 20px;">
                    <li>초당 수백만 건의 이벤트 처리</li>
                    <li>시스템 간 느슨한 결합</li>
                    <li>비동기 통신으로 성능 향상</li>
                    <li>데이터 영속성 보장</li>
                </ul>
            </div>
            
            <h3>Kafka 아키텍처</h3>
            <div class="diagram-container">
                <div class="diagram-title">Kafka 메시징 플로우</div>
                <div class="mermaid">
graph LR
    A[Producer 1] --> D[Kafka Broker]
    B[Producer 2] --> D
    C[Producer 3] --> D
    D --> E[Topic: orders]
    D --> F[Topic: payments]
    E --> G[Consumer Group A]
    E --> H[Consumer Group B]
    F --> I[Consumer Group C]
    
    G --> J[Consumer 1]
    G --> K[Consumer 2]
    
    style D fill:#FF6B35,color:#fff
    style E fill:#2E5090,color:#fff
    style F fill:#2E5090,color:#fff
                </div>
            </div>
            
            <h3>핵심 구성 요소</h3>
            <div class="card-grid">
                <div class="card">
                    <div class="card-icon">📮</div>
                    <h4>Producer</h4>
                    <p>메시지를 생성하여 Topic에 발행하는 역할</p>
                </div>
                <div class="card">
                    <div class="card-icon">🖥️</div>
                    <h4>Broker</h4>
                    <p>메시지를 저장하고 관리하는 서버</p>
                </div>
                <div class="card">
                    <div class="card-icon">📥</div>
                    <h4>Consumer</h4>
                    <p>Topic에서 메시지를 읽어 처리</p>
                </div>
            </div>
            
            <h3>Consumer Group의 병렬 처리</h3>
            <div class="diagram-container">
                <div class="diagram-title">Partition과 Consumer 매핑</div>
                <div class="mermaid">
graph TD
    A[Topic: orders<br/>3 Partitions] --> B[Partition 0]
    A --> C[Partition 1]
    A --> D[Partition 2]
    
    E[Consumer Group] --> F[Consumer 1]
    E --> G[Consumer 2]
    E --> H[Consumer 3]
    
    B --> F
    C --> G
    D --> H
    
    style A fill:#2E5090,color:#fff
    style E fill:#5B9BD5,color:#fff
                </div>
            </div>
            
            <h3>학습 내용</h3>
            
            <h4>2-1. Kafka 필요성</h4>
            <ul>
                <li>동기 vs 비동기 통신의 차이와 장단점</li>
                <li>메시지 큐와 이벤트 스트리밍의 개념</li>
                <li>Kafka가 해결하는 실무 문제들</li>
            </ul>
            
            <h4>2-2. Kafka 개념</h4>
            <ul>
                <li>핵심 구성 요소: Producer, Broker, Consumer</li>
                <li>Topic과 Partition의 개념</li>
                <li>Offset의 역할과 메시지 순서 보장</li>
                <li>Replication을 통한 고가용성 확보</li>
            </ul>
            
            <h4>2-3 ~ 2-6. Kafka 실습</h4>
            <div class="info-box">
                <strong>Kafka-UI를 통한 시각화</strong><br>
                실시간으로 Topic, Partition, Consumer Group을 모니터링하며 학습합니다.
            </div>
            
            <div class="flow-step">
                <div class="flow-number">1</div>
                <div class="flow-content">Broker와 Consumer Group 이해</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">2</div>
                <div class="flow-content">Kafka 클러스터 구조 학습</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">3</div>
                <div class="flow-content">Docker Compose로 클러스터 구축</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">4</div>
                <div class="flow-content">장애 시나리오 실습</div>
            </div>
        </div>
        
        <!-- 챕터 3: Kafka + Spring -->
        <div id="chapter3" class="section">
            <h2>🔧 챕터 3: Kafka + Spring</h2>
            
            <h3>Spring Boot와 Kafka 통합</h3>
            <p>Spring Kafka는 Kafka를 Spring 애플리케이션에 쉽게 통합할 수 있도록 도와주는 프레임워크입니다. 복잡한 설정을 간소화하고 개발 생산성을 크게 향상시킵니다.</p>
            
            <h3>통합 아키텍처</h3>
            <div class="diagram-container">
                <div class="diagram-title">Spring Boot + Kafka 구조</div>
                <div class="mermaid">
graph LR
    A[Spring Boot App] --> B[KafkaTemplate]
    B --> C[Kafka Broker]
    C --> D[@KafkaListener]
    D --> A
    
    E[Custom Object] --> F[JsonSerializer]
    F --> C
    C --> G[JsonDeserializer]
    G --> H[Custom Object]
    
    style A fill:#2E5090,color:#fff
    style C fill:#FF6B35,color:#fff
                </div>
            </div>
            
            <h3>학습 내용</h3>
            
            <h4>3-1. Spring Boot + Kafka 기본 설정</h4>
            <ul>
                <li>Spring Kafka 의존성 추가</li>
                <li>application.yml 설정 (bootstrap-servers, group-id)</li>
                <li>KafkaTemplate을 이용한 메시지 발행</li>
                <li>@KafkaListener를 이용한 메시지 소비</li>
            </ul>
            
            <h4>3-2. Kafka 커스텀 객체 사용하기</h4>
            <div class="info-box">
                <strong>실전 예제:</strong> 주문 이벤트 객체를 JSON으로 직렬화하여 전송하고, Consumer에서 역직렬화하여 처리합니다.
            </div>
            
            <h4>3-3. Offset과 Commit</h4>
            <div class="diagram-container">
                <div class="diagram-title">Offset 관리 메커니즘</div>
                <div class="mermaid">
sequenceDiagram
    participant C as Consumer
    participant K as Kafka
    participant Z as __consumer_offsets
    
    C->>K: 메시지 조회
    K->>C: 메시지 반환 (offset: 100)
    C->>C: 메시지 처리
    C->>Z: Commit offset: 101
    
    Note over C,Z: 재시작 시 offset 101부터 읽음
                </div>
            </div>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Commit 방식</th>
                        <th>특징</th>
                        <th>활용 시나리오</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Auto Commit</strong></td>
                        <td>자동으로 주기적 커밋</td>
                        <td>처리 실패해도 괜찮은 경우</td>
                    </tr>
                    <tr>
                        <td><strong>Manual Commit</strong></td>
                        <td>처리 완료 후 수동 커밋</td>
                        <td>정확성이 중요한 경우</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>3-4. Kafka 에러 처리</h4>
            <div class="diagram-container">
                <div class="diagram-title">에러 처리 플로우 (DLT 패턴)</div>
                <div class="mermaid">
graph TD
    A[메시지 수신] --> B{처리 성공?}
    B -->|성공| C[Commit]
    B -->|실패| D{Retry}
    D -->|성공| C
    D -->|3회 실패| E[Dead Letter Topic]
    E --> F[수동 분석 및 재처리]
    
    style E fill:#FF6B35,color:#fff
    style C fill:#5B9BD5,color:#fff
                </div>
            </div>
            
            <div class="warning-box">
                <strong>⚠️ 중요:</strong> Dead Letter Topic(DLT)을 구성하여 실패한 메시지를 격리하고, 모니터링을 통해 문제를 빠르게 파악합니다.
            </div>
            
            <h4>3-5. Kafka 운영 Best Practice</h4>
            <ul>
                <li><strong>Producer 최적화:</strong> acks, batch.size, linger.ms 설정</li>
                <li><strong>Consumer 최적화:</strong> fetch.min.bytes, max.poll.records 설정</li>
                <li><strong>Partition 전략:</strong> 트래픽에 맞는 적절한 Partition 개수</li>
                <li><strong>Idempotent Producer:</strong> 중복 메시지 방지</li>
                <li><strong>모니터링:</strong> 지연(Lag), 처리량(TPS) 추적</li>
            </ul>
        </div>
        
        <!-- 챕터 4: 실전 프로젝트 -->
        <div id="chapter4" class="section">
            <h2>💼 챕터 4: 실전 프로젝트</h2>
            
            <div class="highlight-box">
                <h3>🎯 학습 목표</h3>
                <p>지금까지 학습한 Redis, Kafka, Spring Boot를 모두 통합하여 실무 수준의 이벤트 기반 시스템을 구축합니다.</p>
            </div>
            
            <div class="project-card">
                <h4><span class="project-number">1</span>실시간 인기 상품 랭킹</h4>
                <p><strong>목표:</strong> 사용자 조회 이벤트를 수집하여 실시간 TOP 100 상품을 제공</p>
                
                <h4 style="font-size: 18px; margin-top: 20px;">📊 시스템 플로우</h4>
                <div class="diagram-container">
                    <div class="mermaid">
sequenceDiagram
    participant U as 사용자
    participant A as API Server
    participant K as Kafka
    participant C as Consumer
    participant R as Redis ZSET
    
    U->>A: 상품 조회
    A->>K: 조회 이벤트 발행
    A->>U: 즉시 응답 (빠름!)
    K->>C: 이벤트 수신
    C->>R: ZINCRBY 상품ID 1
    
    Note over R: 실시간 랭킹 업데이트
    
    U->>A: TOP 100 요청
    A->>R: ZREVRANGE 0 99
    R->>A: 상위 100개
    A->>U: 랭킹 반환
                    </div>
                </div>
                
                <h4 style="font-size: 18px; margin-top: 20px;">💡 구현 포인트</h4>
                <ul>
                    <li>Kafka를 통한 비동기 집계로 API 응답 시간 단축</li>
                    <li>Redis ZSET으로 O(log N) 성능의 실시간 정렬</li>
                    <li>대용량 트래픽에서도 안정적인 처리</li>
                </ul>
            </div>
            
            <div class="project-card">
                <h4><span class="project-number">2</span>실시간 상품 결제 히스토리 기록</h4>
                <p><strong>목표:</strong> 결제 이벤트를 비동기로 처리하여 히스토리 안전하게 보관</p>
                
                <h4 style="font-size: 18px; margin-top: 20px;">📊 시스템 플로우</h4>
                <div class="diagram-container">
                    <div class="mermaid">
graph LR
    A[결제 완료] --> B[Kafka: payment-events]
    B --> C[Consumer]
    C --> D[DB 저장]
    C --> E[통계 생성]
    
    style B fill:#FF6B35,color:#fff
    style D fill:#5B9BD5,color:#fff
                    </div>
                </div>
                
                <h4 style="font-size: 18px; margin-top: 20px;">💡 구현 포인트</h4>
                <ul>
                    <li>결제 API는 즉시 응답하고, 히스토리는 백그라운드 처리</li>
                    <li>트랜잭션 관리 및 예외 처리</li>
                    <li>실패 시 DLT로 메시지 격리</li>
                </ul>
            </div>
            
            <div class="project-card">
                <h4><span class="project-number">3</span>결제 완료 기반 배송 흐름 구성</h4>
                <p><strong>목표:</strong> 이벤트 체인으로 결제 → 배송 프로세스 자동화</p>
                
                <h4 style="font-size: 18px; margin-top: 20px;">📊 이벤트 체인 플로우</h4>
                <div class="diagram-container">
                    <div class="mermaid">
graph LR
    A[결제 완료] --> B[payment-completed]
    B --> C[Payment Consumer]
    C --> D[재고 확인]
    D --> E[shipping-requested]
    E --> F[Shipping Consumer]
    F --> G[배송 업체 연동]
    G --> H[배송 시작]
    
    style B fill:#2E5090,color:#fff
    style E fill:#5B9BD5,color:#fff
    style H fill:#FF6B35,color:#fff
                    </div>
                </div>
                
                <h4 style="font-size: 18px; margin-top: 20px;">💡 구현 포인트</h4>
                <ul>
                    <li>이벤트 기반 느슨한 결합: 각 서비스가 독립적으로 동작</li>
                    <li>Saga 패턴으로 분산 트랜잭션 관리</li>
                    <li>중복 처리 방지 (Idempotency)</li>
                    <li>각 단계별 상태 추적</li>
                </ul>
            </div>
            
            <h3>에러 대응 전략</h3>
            <div class="info-box">
                <h4>🛡️ Idempotency (멱등성) 구현</h4>
                <p>동일한 이벤트가 여러 번 처리되어도 결과는 동일하게 유지되도록 Redis를 활용한 중복 체크를 구현합니다.</p>
            </div>
            
            <div class="warning-box">
                <h4>⚠️ Dead Letter Topic 활용</h4>
                <p>처리에 실패한 메시지는 DLT로 격리하여 서비스 장애를 방지하고, 추후 분석 및 재처리를 수행합니다.</p>
            </div>
        </div>
        
        <!-- 챕터 5: 부하 테스트 -->
        <div id="chapter5" class="section">
            <h2>📊 챕터 5: 부하 테스트</h2>
            
            <h3>부하 테스트의 중요성</h3>
            <p>아무리 잘 설계된 시스템이라도 실제 트래픽을 받기 전까지는 성능을 장담할 수 없습니다. 부하 테스트를 통해 시스템의 한계를 파악하고 병목 지점을 개선합니다.</p>
            
            <div class="card-grid">
                <div class="card">
                    <div class="card-icon">📈</div>
                    <h4>Load Test</h4>
                    <p>정상 트래픽에서의 성능 측정</p>
                </div>
                <div class="card">
                    <div class="card-icon">⚡</div>
                    <h4>Stress Test</h4>
                    <p>한계점까지 부하 증가</p>
                </div>
                <div class="card">
                    <div class="card-icon">🚀</div>
                    <h4>Spike Test</h4>
                    <p>급격한 트래픽 증가 시뮬레이션</p>
                </div>
            </div>
            
            <h3>K6 부하 테스트 도구</h3>
            <div class="info-box">
                <strong>K6란?</strong> JavaScript로 시나리오를 작성하는 현대적인 부하 테스트 도구입니다. 실시간 메트릭과 CI/CD 통합이 용이합니다.
            </div>
            
            <h3>부하 테스트 시나리오</h3>
            <div class="diagram-container">
                <div class="diagram-title">단계적 부하 증가 (Ramp-up)</div>
                <div class="mermaid">
graph LR
    A[0 VUs] -->|5분| B[100 VUs]
    B -->|10분| C[500 VUs]
    C -->|10분| D[1000 VUs]
    D -->|5분| E[0 VUs]
    
    style C fill:#FF6B35,color:#fff
    style D fill:#FF0000,color:#fff
                </div>
            </div>
            
            <h3>성능 지표 분석</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>지표</th>
                        <th>설명</th>
                        <th>목표 값</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>TPS</strong></td>
                        <td>초당 처리 건수</td>
                        <td>1000+ TPS</td>
                    </tr>
                    <tr>
                        <td><strong>평균 응답시간</strong></td>
                        <td>모든 요청의 평균 시간</td>
                        <td>&lt; 200ms</td>
                    </tr>
                    <tr>
                        <td><strong>p95 응답시간</strong></td>
                        <td>95%의 요청이 이 시간 내 처리</td>
                        <td>&lt; 500ms</td>
                    </tr>
                    <tr>
                        <td><strong>에러율</strong></td>
                        <td>실패한 요청 비율</td>
                        <td>&lt; 0.1%</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>성능 개선 실습 예시</h3>
            <div class="project-card">
                <h4>상품 조회 API 개선</h4>
                
                <table class="comparison-table" style="margin-top: 20px;">
                    <thead>
                        <tr>
                            <th>구분</th>
                            <th>Before (DB 직접 조회)</th>
                            <th>After (Redis 캐시)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>평균 응답시간</strong></td>
                            <td>350ms</td>
                            <td><span style="color: #2E5090; font-weight: bold;">45ms</span></td>
                        </tr>
                        <tr>
                            <td><strong>TPS</strong></td>
                            <td>500</td>
                            <td><span style="color: #2E5090; font-weight: bold;">3500</span></td>
                        </tr>
                        <tr>
                            <td><strong>DB 부하</strong></td>
                            <td>높음</td>
                            <td><span style="color: #2E5090; font-weight: bold;">낮음</span></td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="highlight-box" style="margin-top: 20px;">
                    <h4 style="color: white; margin: 0 0 10px 0;">📈 개선 효과</h4>
                    <ul style="color: white; margin: 0 0 0 20px;">
                        <li>응답 시간 <strong>87% 감소</strong></li>
                        <li>처리량 <strong>7배 증가</strong></li>
                        <li>DB 부하 <strong>90% 감소</strong></li>
                    </ul>
                </div>
            </div>
            
            <h3>학습 내용</h3>
            <div class="flow-step">
                <div class="flow-number">1</div>
                <div class="flow-content"><strong>K6 시작하기:</strong> 설치, 시나리오 작성, 실행</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">2</div>
                <div class="flow-content"><strong>결과 분석:</strong> 메트릭 읽기, 병목 지점 찾기</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">3</div>
                <div class="flow-content"><strong>성능 개선:</strong> 캐시 적용, 쿼리 최적화</div>
            </div>
            <div class="flow-step">
                <div class="flow-number">4</div>
                <div class="flow-content"><strong>재측정:</strong> 개선 효과 정량적 검증</div>
            </div>
        </div>
        
        <!-- 학습 효과 및 요약 -->
        <div id="summary" class="section">
            <h2>🎓 학습 효과 및 커리큘럼 요약</h2>
            
            <h3>학습 후 기대 효과</h3>
            <div class="card-grid">
                <div class="card">
                    <div class="card-icon">🚀</div>
                    <h4>기술 역량</h4>
                    <ul style="font-size: 14px; color: #666;">
                        <li>Redis 실시간 랭킹</li>
                        <li>Kafka 이벤트 처리</li>
                        <li>Spring Boot 통합</li>
                        <li>K6 부하 테스트</li>
                    </ul>
                </div>
                <div class="card">
                    <div class="card-icon">🏗️</div>
                    <h4>설계 능력</h4>
                    <ul style="font-size: 14px; color: #666;">
                        <li>대규모 트래픽 대응</li>
                        <li>이벤트 기반 설계</li>
                        <li>확장 가능한 구조</li>
                        <li>장애 대응 전략</li>
                    </ul>
                </div>
                <div class="card">
                    <div class="card-icon">💼</div>
                    <h4>실무 경험</h4>
                    <ul style="font-size: 14px; color: #666;">
                        <li>프로덕션 수준 코드</li>
                        <li>Best Practice 적용</li>
                        <li>성능 최적화</li>
                        <li>포트폴리오 구축</li>
                    </ul>
                </div>
            </div>
            
            <h3>전체 커리큘럼 요약</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>챕터</th>
                        <th>주제</th>
                        <th>주요 학습 내용</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>챕터 1</strong></td>
                        <td>Redis ZSET</td>
                        <td>환경 설정, ZSET 자료구조, Spring 연동, 실시간 랭킹</td>
                    </tr>
                    <tr>
                        <td><strong>챕터 2</strong></td>
                        <td>Kafka</td>
                        <td>필요성, 핵심 개념, Broker/Consumer Group, 클러스터 구조</td>
                    </tr>
                    <tr>
                        <td><strong>챕터 3</strong></td>
                        <td>Kafka + Spring</td>
                        <td>Spring 통합, 커스텀 객체, Offset/Commit, 에러 처리</td>
                    </tr>
                    <tr>
                        <td><strong>챕터 4</strong></td>
                        <td>실전 프로젝트</td>
                        <td>인기 랭킹, 결제 히스토리, 배송 흐름, 중복 방지</td>
                    </tr>
                    <tr>
                        <td><strong>챕터 5</strong></td>
                        <td>부하 테스트</td>
                        <td>K6 도구, 테스트 시나리오, 결과 분석, 성능 개선</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="highlight-box" style="margin-top: 40px;">
                <h3>👥 이런 분들께 추천합니다</h3>
                <ul style="color: white; margin: 10px 0 0 20px; font-size: 16px;">
                    <li>Spring Boot 기본기는 있지만 대용량 트래픽 처리 경험이 부족한 개발자</li>
                    <li>Redis, Kafka를 실제 프로젝트에 적용해보고 싶은 개발자</li>
                    <li>실시간 랭킹, 이벤트 처리 시스템을 구축해야 하는 개발자</li>
                    <li>마이크로서비스 아키텍처에 관심 있는 개발자</li>
                    <li>실무 프로젝트 경험으로 포트폴리오를 강화하고 싶은 개발자</li>
                </ul>
            </div>
        </div>
        
        <!-- 푸터 -->
        <div class="footer">
            <p style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">🎯</p>
            <p>이론과 실습을 통해 대규모 트래픽을 다루는 개발자로 성장하세요!</p>
        </div>
    </div>
    
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                fontSize: '16px'
            }
        });
    </script>
</body>
</html>
